\documentclass[11pt]{article}

\usepackage{epsfig}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsmath}
\usepackage{xspace}
\usepackage{theorem}
\usepackage{times}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}

%\usepackage{layout}% if you want to see the layout parameters
                     % and now use \layout command in the body

% This is the stuff for normal spacing
\makeatletter
 \setlength{\textwidth}{6.5in}
 \setlength{\oddsidemargin}{0in}
 \setlength{\evensidemargin}{0in}
 \setlength{\topmargin}{0.25in}
 \setlength{\textheight}{8.25in}
 \setlength{\headheight}{0pt}
 \setlength{\headsep}{0pt}
 \setlength{\marginparwidth}{59pt}

 \setlength{\parindent}{0pt}
 \setlength{\parskip}{5pt plus 1pt}
 \setlength{\theorempreskipamount}{5pt plus 1pt}
 \setlength{\theorempostskipamount}{0pt}
 \setlength{\abovedisplayskip}{8pt plus 3pt minus 6pt}

 \renewcommand{\section}{\@startsection{section}{1}{0mm}%
                                   {2ex plus -1ex minus -.2ex}%
                                   {1.3ex plus .2ex}%
                                   {\normalfont\Large\bfseries}}%
 \renewcommand{\subsection}{\@startsection{subsection}{2}{0mm}%
                                     {1ex plus -1ex minus -.2ex}%
                                     {1ex plus .2ex}%
                                     {\normalfont\large\bfseries}}%
 \renewcommand{\subsubsection}{\@startsection{subsubsection}{3}{0mm}%
                                     {1ex plus -1ex minus -.2ex}%
                                     {1ex plus .2ex}%
                                     {\normalfont\normalsize\bfseries}}
 \renewcommand{\paragraph}{\@startsection{paragraph}{4}{0mm}%
                                    {1ex \@plus1ex \@minus.2ex}%
                                    {-1em}%
                                    {\normalfont\normalsize\bfseries}}
 \renewcommand{\subparagraph}{\@startsection{subparagraph}{5}{\parindent}%
                                       {2.0ex \@plus1ex \@minus .2ex}%
                                       {-1em}%
                                      {\normalfont\normalsize\bfseries}}
\makeatother

\newenvironment{proof}{{\bf Proof:  }}{\hfill\rule{2mm}{2mm}}
\newenvironment{proofof}[1]{{\bf Proof of #1:  }}{\hfill\rule{2mm}{2mm}}
\newenvironment{proofofnobox}[1]{{\bf#1:  }}{}
\newenvironment{example}{{\bf Example:  }}{\hfill\rule{2mm}{2mm}}
\renewcommand{\thesection}{\arabic{section}}
\renewcommand\thesubsection{\thesection.\alph{subsection}}


\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}

\newtheorem{fact}{Fact}[section]
\newtheorem{lemma}[fact]{Lemma}
\newtheorem{theorem}[fact]{Theorem}
\newtheorem{definition}[fact]{Definition}
\newtheorem{corollary}[fact]{Corollary}
\newtheorem{proposition}[fact]{Proposition}
\newtheorem{claim}[fact]{Claim}
\newtheorem{exercise}[fact]{Exercise}

% math notations
\newcommand{\R}{\ensuremath{\mathbb R}}
\newcommand{\Z}{\ensuremath{\mathbb Z}}
\newcommand{\N}{\ensuremath{\mathbb N}}
\newcommand{\F}{\ensuremath{\mathcal F}}
\newcommand{\SymGrp}{\ensuremath{\mathfrak S}}

\newcommand{\size}[1]{\ensuremath{\left|#1\right|}}
\newcommand{\ceil}[1]{\ensuremath{\left\lceil#1\right\rceil}}
\newcommand{\floor}[1]{\ensuremath{\left\lfloor#1\right\rfloor}}
\newcommand{\poly}{\operatorname{poly}}
\newcommand{\polylog}{\operatorname{polylog}}

% asymptotic notations
\newcommand{\Oh}[1]{{\mathcal O}\left({#1}\right)}
\newcommand{\LOh}[1]{{\mathcal O}\left({#1}\right.}
\newcommand{\ROh}[1]{{\mathcal O}\left.{#1}\right)}
\newcommand{\oh}[1]{{o}\left({#1}\right)}
\newcommand{\Om}[1]{{\Omega}\left({#1}\right)}
\newcommand{\om}[1]{{\omega}\left({#1}\right)}
\newcommand{\Th}[1]{{\Theta}\left({#1}\right)}


% pseudocode notations
\newcommand{\xif}{{\bf{\em{if~}}}}
\newcommand{\xthen}{{\bf{\em{then~}}}}
\newcommand{\xelse}{{\bf{\em{else~}}}}
\newcommand{\xelseif}{{\bf{\em{elif~}}}}
\newcommand{\xfi}{{\bf{\em{fi~}}}}
\newcommand{\xcase}{{\bf{\em{case~}}}}
\newcommand{\xendcase}{{\bf{\em{endcase~}}}}
\newcommand{\xfor}{{\bf{\em{for~}}}}
\newcommand{\xto}{{\bf{\em{to~}}}}
\newcommand{\xby}{{\bf{\em{by~}}}}
\newcommand{\xdownto}{{\bf{\em{downto~}}}}
\newcommand{\xdo}{{\bf{\em{do~}}}}
\newcommand{\xrof}{{\bf{\em{rof~}}}}
\newcommand{\xwhile}{{\bf{\em{while~}}}}
\newcommand{\xendwhile}{{\bf{\em{endwhile~}}}}
\newcommand{\xand}{{\bf{\em{and~}}}}
\newcommand{\xor}{{\bf{\em{or~}}}}
\newcommand{\xerror}{{\bf{\em{error~}}}}
\newcommand{\xreturn}{{\bf{\em{return~}}}}
\newcommand{\xparallel}{{\bf{\em{parallel~}}}}
\newcommand{\T}{\hspace{0.5cm}}
\newcommand{\m}{\mathcal}

\def\sland{~\land~}
\def\slor{~\lor~}
\def\sRightarrow{~\Rightarrow~}

\def\comment#1{\hfill{$\left\{\textrm{{\em{#1}}}\right\}$}}
\def\lcomment#1{\hfill{$\left\{\textrm{{\em{#1}}}\right.$}}
\def\rcomment#1{\hfill{$\left.\textrm{{\em{#1}}}\right\}$}}
\def\fcomment#1{\hfill{$\textrm{{\em{#1}}}$}}
\def\func#1{\textrm{\bf{\sc{#1}}}}
\def\funcbf#1{\textrm{\textbf{\textsc{#1}}}}

\newcommand{\hide}[1]{}

\newcommand{\prob}[1]{\ensuremath{\text{{\bf Pr}$\left[#1\right]$}}}
\newcommand{\expct}[1]{\ensuremath{\text{{\bf E}$\left[#1\right]$}}}
\newcommand{\Event}{{\mathcal E}}

\newcommand{\mnote}[1]{\normalmarginpar \marginpar{\tiny #1}}

\makeatletter
   \newcommand\figcaption{\def\@captype{figure}\caption}
   \newcommand\tabcaption{\def\@captype{table}\caption}
\makeatother


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Document begins here %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\headings}[3]{
{\bf CSE638 \& AMS641: Advanced Algorithms} \hfill {{\bf Lecturer:} #1}\\
{{\bf Submitted by:} #2} \hfill {{\bf Date:} #3} \\
\\
\rule[0.1in]{\textwidth}{0.025in}
%\thispagestyle{empty}
}

\begin{document}

\headings{Prof. Rezaul A. Chowdhury}{Yoni Fogel, Arun Rathakrishnan and Amitav Paul}{March 12, 2013}
\newcommand{\lecnum}{1}  % Lecture Number

{\centerline {\Huge Homework \# 1}}
\section{Parallel BFS with Work Stealing}
     
\subsection{}
See Graph::serial \_ bfs() in bfs.cc

\subsection{}

- In {\it PARALLEL-BFS}, the following race conditions may occur, but will not affect the correctness of the output:

- In {\it PARALLEL-BFS-THREAD}, multiple cores can be on line $5$ with the same vertex $v$. It is then possible for two (or more) threads to call line $6$
at the same time for $v$.  This does not affect correctness because all threads are writing the same value.

- In {\it PARALLEL-BFS-THREAD}, when stealing, we lock the thief and victim, but only protecting from other thieves.  There can be a race condition if
the victim is fast (or MIN-STEAL-SIZE $\approx |Q^{in}.q[$victim$]|$, where the victim explores some vertexes that were ALSO stolen.
This does not affect correctness, it only slightly impacts performance.

\subsection{}
- One vertex can be the end point of many vertexes. So, one vertex can be multiple times in $Q^{in}$. In case of stealing, due to overlapping of execution thief and victim may process the same vertex. So that same vertex can exist multiple times in $Q^{in}$.

- So, one vertex can not be more than one time in any $Q^{in}.q[i]$ because the check on line 5 of bfs-thread (and a single queue is serialized). It may end up in different queues (see race conditions above).

- We can add an additional field {\it c[v]} for each vertex {\it v} which will keep the track of the processor by which it discovered. i.e. $\mathbf{c[v] = i}$ in between line 6-7 in PARALLEL-BFS-THREAD.

And before expanding a vertex we check whether the vertex is discovered by this thread or not by checking {\it c[v]}. i.e. we can add \xif $\mathbf{(c[v] = i)}$ before \xfor loop at line 4 in PARALLEL-BFS-THREAD. So, only the processor who have won in the race condition for vertex v has right to expand it.\\  Note this does not affect correctness because exactly one processor will win the race (if it happens).

- A single vertex cannot be in queues from multiple levels because we store the length of the shortest path to each node.  If we later find a longer path we do not overwrite it.

\subsection{}
We consider phases of $p$ steals each.\\
Let $F_i = \ceil {\frac {|q_i|}{MIN-STEAL-SIZE}}$

The potential of $Q_i = W_i = {F_i}^2$\\
Let \[
S_i = \begin{cases}
1 , $ No steal attempts on this processor during this phase$\\
0 , $  otherwise$
\end{cases}
\]

When at least one steal attempt happens on a victim processor, the potential of the whole system drops by at least
$W_i - (\frac{W_i}{4}) - (\frac{W_i}{4}) = \frac{W_i}{2}$ (Trivially for empty queues).

$X_i = W_i S_i$ is the portion of the potential that was involved in attempted steals.
The potential drop of the whole system $\ge X_i/2$.


$E[S_i] = 1 - {(1-\frac{1}{p})}^p \geq (1-\frac{1}{e}) \geq \frac{1}{2}$

Now, \[
E \left[ X \right] = \sum \limits_{i=1}^p E \left[ X_i \right] > \left( 1 - \frac{1}{e} \right) \sum \limits_{i=1}^p E[W_i] >\left( 1 - \frac{1}{e} \right) E \left [W \right ]
\]

By Markov's inequality,\\
\[Pr \left( X < \beta [W] \right) = Pr \left( W - X > (1 - \beta)[W] \right) < \frac {E \left[ [W] - X \right]}{\left(1 - \beta \right)  E[W]} < \frac {1}{\left(1 - \beta \right) e }
\] \\\\\\\\

Setting $\beta = \frac {1}{2}$ in Lemma \ref{thm:bbins}, we get,
\[
Pr \left( X < \frac{1}{2} \Phi_i \right) < \frac {2}{e} \implies Pr \left( X > \frac{1}{2} \Phi_i \right) \ge \left( 1 - \frac {2}{e} \right) = \frac {1}{4}
\]

Consider time steps, $i$ and $j$ such that $j > i$ and at least p steal attempts occur between time steps i (inclusive) and j (exclusive) then,
\[
    Pr \left( \Phi_i - \Phi_j > \frac{\Phi_i}{4}\right)  > \frac {1}{4}.
\]

Similar to Quicksort, Cilk Stealing, and other randomized algorithms, when a phase reduces a total by at least a constant fraction by at least a constant probability,
takes $O(\log x)$ times the expected number of phases w.h.p in $x$ to reduce to any constant.




\subsection{}
Assuming there is at least one core to steal from, the probability that a core
tries to steal $cp\log p$ times and never chooses any of those cores $\le {(1-\frac{1}{p})}^{cp \log p} = {({(1-\frac{1}{p})}^p)}^{clnp} = {(\frac{1}{e})}^{clnp} = \frac{1}{p^c}$

So MAX-STEAL-ATTEMPTS = $cp\ln p, c>1$ means that if any cores have enough work to be stolen from,
any core trying to steal will choose at least one of them with high probability in p.

Moreover, in reference of {\it Task 1(d)}, it can be shown that  $cp^2 \ln p, c>1$ ($p$ cores have to steal before finishing bfs-thread)
is more than the expected number of steal attempts before all steal attempts in the system fail.

\subsection{}
MIN-STEAL-SIZE is assumed to be $\Theta(1)$.

$T_p$:

Waiting to launch: $O(Dp)$.

Stealing: $O(D p \log p + D \log p \log n)$ With high probability in p.

Exploring: $O(D \Delta  + \frac{n}{p} + \frac{m}{p})$ worst case.

Synchronization: $O(D \log p)$ worst case.

So, $T_p = O( D(p \log p + \log p \log n + \Delta) + \frac{n+m}{p})$ with high probability in p.

Total work:

Stealing: $O(D p^2 \log p + Dp\log p \log n)$ with high probability in p.

Exploring: $O(n + m)$ worst case.

Synchronization: $O(D p)$

So, total work is $O( D(p^2 \log p + p\log p\log n) + n + m)$

Lower Bound for size of the input graph where total work is work optimal ($O(n+m)$):

$m+n = \Omega(D(p^2 \log p + p\log p\log n))$.



\subsection{}
Operate as normal.  When you try to steal from a victim with fewer than MIN-STEAL-SIZE vertexes,
switch to stealing half the out degrees remaining.  Instead of $D p\log p\log q_l$ steals with high probability,
it's $D p \log p \log (q_l\Delta)$ steals.

Assuming MIN-STEAL-SIZE $= \Theta(1)$ means it takes constant time to split the queue into two pieces,
with additional information to say which outgoing edges should be done by the victim and which by the thief.

Without the assumption you can do a serial prefix-sum of the remaining nodes the first time you try to steal
edges (instead of nodes).  Then you can do MIN-STEAL-SIZE work for free (charge against one of the successful steals)
Then you can fail to steal in $O(1)$ time and successfully steal in $O($MIN-STEAL-SIZE$)$ time.

The analysis from $f$ remains the same, except that $\Delta$ disappears entirely.

\subsection{}
We can replace \xfor by \xparallel \xfor in line 10 of {\it figure 2} and do all $p$ spawns in parallel.
This changes the time spent waiting to start from $O(Dp)$ to $O(D\log p)$ but both are dominated by other terms
so it does not change the upper bound of either $f$ or $g$.



\subsection{}
See Graph::parallel \_ bfs() in bfs.cc
You can do all $2^3$ versions of the algorithm by independently turning on the optimizations from $c$, $g$, and $h$.\\
The optimal value occurs when $8p\log p$ is MAX-STEAL-ATTEMPTS and 196 is MIN-STEAL-SIZE for the Wikipedia graph. 
\begin {table}[H]
\begin{center}
    \begin{tabular}{ | c | c | c |}
    \hline
    MAX-STEAL-ATTEMPTS &MIN-STEAL-SIZE & Time \\ \hline
    8 & 32 & 705.017 \\ \hline
    8 & 64 & 705.774 \\ \hline
    8 & 128 & 695.900 \\ \hline
	8 & 196 & 705.940 \\ \hline
    16 & 32 & 706.917 \\ \hline
    16 & 64 & 703.42 \\ \hline
            
    \end{tabular}
    \caption {Run for Wikipedia.}
\end{center}
\end {table}


\subsection{}

\begin {table}[H]
\begin{center}
    \begin{tabular}{ | c | c | c | c | c | c |}
    \hline
    Input File & $RT_{SBFS}$ & $RT_{PBFS^{(f)}}$ & $RT_{PBFS^{(g)}}$ & $SF_{PBFS^{(f)}}$ & $SF_{PBFS^{(g)}}$\\ \hline
    cage14 & 1786 & 313 & 315.18 & 5.70 & 5.67 \\ \hline
    cage15 & 1231 & 303.904 & 303.75 & 4.05 & 4.05 \\ \hline
    freescale & 1835 & 223 & 253.00 & 8.22 & 7.25 \\ \hline
	Wikipedia & 709 & 705.47 & 703 & 1.00 & 1.00 \\ \hline
    kkt-power & 410 & 21.5 & 20.79 & 19.07 & 19.72 \\ \hline
    RMAT100M & 3253 & 673.57 & 647.00 & 4.83 & 5.03 \\ \hline
    RMAT1B & - & 2544.57 & - & - & - \\ \hline
        
    \end{tabular}
    \caption {RT = Running Time, SBFS = Serial BFS, $PBFS^{(f)}$ = Parallel BFS for task 1(f), $PBFS^{(g)}$ = Parallel BFS for task 1(g) and SF = Speed Factor. Times are in seconds.}
\end{center}
\end {table}

\end{document}